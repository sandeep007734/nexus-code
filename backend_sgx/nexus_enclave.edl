enclave {
    include "sgx_report.h"
    include "sgx_quote.h"
    include "sgx_trts.h"
    include "sgx_backend_common.h"

    trusted {

        /**
         * Initializes the enclave with the specified backend info
         * @param backend_info
         * @return 0 on success
         */
        public int ecall_init_enclave
        (
            [user_check] struct nexus_volume    * volume,
            [user_check] struct nexus_heap      * heap
        );

        /**
         * Creates a new nexus instance for this computer
         */
        public int ecall_new_instance
        (
            [in]         const sgx_target_info_t  * target_info_IN,
            [out]        sgx_report_t             * report_out,
            [user_check] struct ecdh_public_key   * pubkey_out,
            [user_check] uint8_t                 ** sealed_privkey_out,
            [user_check] size_t                   * sealed_privkey_len_out
        );

        public int ecall_mount_instance
        (
            [in]         struct ecdh_public_key   * pubkey_IN,
            [user_check] uint8_t                  * sealed_privkey_in,
                         size_t                     sealed_privkey_len
        );


        // volume management

        /**
         * Creates a new volume
         *
         * @param user_pubkey_in
         * @param supernode_uuid_out
         * @param volkey_buffer_uuid_out
         */
        public int ecall_create_volume
        (
            [in, string] char                    * user_pubkey_IN,
            [user_check] struct nexus_uuid       * supernode_uuid_out,
            [user_check] struct nexus_key_buffer * sealed_volkey_buffer_out
        );

        public int ecall_authentication_challenge
        (
            [in, string] char                    * user_pubkey_IN,
            [in]         struct nexus_key_buffer * sealed_volkey_buffer_out,
            [user_check] struct nonce_challenge  * challenge_out
        );

        public int ecall_authentication_response
        (
            [in]         struct nexus_uuid * supernode_buffer_in,
            [user_check] uint8_t           * signature_buffer_in,
                         size_t              signature_len
        );


        // directory operations
        public int ecall_fs_create
        (
            [in, string] char                * directory_IN,
            [in, string] char                * filename_IN,
                         nexus_dirent_type_t   type_IN,
                   [out] struct nexus_uuid   * uuid_out
        );

        public int ecall_fs_remove
        (
            [in, string] char                * directory_IN,
            [in, string] char                * filename_IN,
                   [out] struct nexus_uuid   * uuid_out
        );

        public int ecall_fs_lookup
        (
            [in, string] char                * directory_IN,
            [in, string] char                * filename_IN,
                   [out] struct nexus_uuid   * uuid_out
        );

        public int ecall_fs_stat
        (
            [in, string] char                * directory_IN,
            [in, string] char                * filename_IN,
            [user_check] struct nexus_stat   * stat_out
        );

        // #define NEXUS_NAME_MAX  256
        public int ecall_fs_filldir
        (
            [in, string] char                * directory_IN,
                    [in] struct nexus_uuid   * uuid_IN,
            [user_check] char                  filename_out[256]
        );

        public int ecall_fs_readdir
        (
            [in, string] char                * directory_IN,
            [user_check] struct nexus_dirent * dirent_buffer_array_out,
                         size_t                dirent_buffer_count_IN,
                         size_t                offset_IN,
            [user_check] size_t              * result_count_out,
            [user_check] size_t              * directory_size_out
        );

        public int ecall_fs_symlink
        (
            [in, string] char                * directory_IN,
            [in, string] char                * linkname_IN,
            [in, string] char                * targetpath_IN,
                   [out] struct nexus_uuid   * uuid_out
        );

        public int ecall_fs_hardlink
        (
            [in, string] char                * link_dirpath_IN,
            [in, string] char                * linkname_IN,
            [in, string] char                * target_dirpath_IN,
            [in, string] char                * targetname_IN,
                   [out] struct nexus_uuid   * uuid_out
        );

        public int ecall_fs_rename
        (
            [in, string] char                * from_dirpath_IN,
            [in, string] char                * oldname_IN,
            [in, string] char                * to_dirpath_IN,
            [in, string] char                * newname_IN,
                   [out] struct nexus_uuid   * old_uuid_out,
                   [out] struct nexus_uuid   * new_uuid_out
        );

        // file operations

        // TODO add argument to indicate moredata
        public int ecall_fs_encrypt
        (
            [in, string] char                * filepath_IN,
            [user_check] uint8_t             * input_buffer_in,
            [user_check] uint8_t             * output_buffer_in,
                         size_t                offset,
                         size_t                size,
                         size_t                filesize
        );

        public int ecall_fs_decrypt
        (
            [in, string] char                * filepath_IN,
            [user_check] uint8_t             * input_buffer_in,
            [user_check] uint8_t             * output_buffer_in,
                         size_t                offset,
                         size_t                size,
                         size_t                filesize
        );


        // ---------------------- user -----------------------
        public int ecall_user_add
        (
            [in, string] char                * username_IN,
            [in, string] char                * user_pubkey_IN
        );

        public int ecall_user_remove_username
        (
            [in, string] char                * username_IN
        );

        public int ecall_user_remove_pubkey
        (
            [in, string] char                * pubkey_str_IN
        );

        public int ecall_user_find_username
        (
            [in, string] char                   * username_IN,
            [user_check] struct nxs_user_buffer * user_buffer_out
        );

        public int ecall_user_find_pubkey
        (
            [in, string] char                   * pubkey_IN,
            [user_check] struct nxs_user_buffer * user_buffer_out
        );

        public int ecall_user_ls
        (
            [user_check] struct nxs_user_buffer * user_buffer_array_in,
                         size_t                   user_buffer_count_IN,
                         size_t                   offset_IN,
            [user_check] size_t                 * total_count_out,
            [user_check] size_t                 * result_count_out
        );
    };


    untrusted {
        // ---------------- metadata management --------------------------
        int
        ocall_buffer_lock
        (
            [in]         struct nexus_uuid   * metadata_uuid,
            [user_check] struct nexus_volume * volume
        );

        int
        ocall_buffer_unlock
        (
            [in]         struct nexus_uuid   * metadata_uuid,
            [user_check] struct nexus_volume * volume
        );

        uint8_t *
        ocall_buffer_get
        (
            [in]         struct nexus_uuid   * metadata_uuid,
                         nexus_io_flags_t      mode,
            [out]        size_t              * buffer_size,
            [out]        size_t              * timestamp,
            [user_check] struct nexus_volume * volume
        );

        int
        ocall_buffer_put
        (
            [in]         struct nexus_uuid   * metadata_uuid,
            [user_check] uint8_t             * buffer,
                         size_t                size,
            [out]        size_t              * timestamp,
            [user_check] struct nexus_volume * volume
        );

        int
        ocall_buffer_new
        (
            [in]         struct nexus_uuid   * metadata_uuid,
            [user_check] struct nexus_volume * volume
        );

        int
        ocall_buffer_del
        (
            [in]         struct nexus_uuid   * metadata_uuid,
            [user_check] struct nexus_volume * volume
        );

        int
        ocall_buffer_hardlink
        (
            [in]         struct nexus_uuid   * link_uuid,
            [in]         struct nexus_uuid   * target_uuid,
            [user_check] struct nexus_volume * volume
        );

        int
        ocall_buffer_rename
        (
            [in]         struct nexus_uuid   * from_uuid,
            [in]         struct nexus_uuid   * to_uuid,
            [user_check] struct nexus_volume * volume
        );

        int
        ocall_buffer_stattime
        (
            [in]         struct nexus_uuid   * uuid,
            [out]        size_t              * timestamp,
            [user_check] struct nexus_volume * volume
        );



        // ---------------------- utilities ---------------------

        /* allocates a buffer in untrusted memory */
        void * ocall_calloc(size_t size);

        /* frees buffer in untrusted memory */
        void ocall_free([user_check] void * untrusted_ptr);

        void ocall_print([in, string] char * str);
    };

};
