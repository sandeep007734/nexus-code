/**
 * File manages the reading and writing of instance keypairs (generated by the enclave)
 * @author Judicael Briand <jbriand@cs.pitt.edu>
 */

#include "internal.h"

#include <nexus_encode.h>


static int
write_keypair(const char             * filepath,
              uint8_t                * quote,
              uint32_t                 quote_len,
              struct ecdh_public_key * pubkey,
              uint8_t                * sealed_privkey,
              uint32_t                 sealed_privkey_len)
{
    char * quote_str   = NULL;
    char * pubkey_str  = NULL;
    char * privkey_str = NULL;


    quote_str = nexus_alt64_encode(quote, quote_len);
    pubkey_str = nexus_alt64_encode(pubkey->bytes, sizeof(struct ecdh_public_key));
    privkey_str = nexus_alt64_encode(sealed_privkey, sealed_privkey_len);

    {
        nexus_json_obj_t json_obj = nexus_json_new_obj(".");

        int ret = 0;

        ret |= nexus_json_add_string(json_obj, "pubkey", pubkey_str);
        ret |= nexus_json_add_string(json_obj, "privkey", privkey_str);
        ret |= nexus_json_add_string(json_obj, "quote", quote_str);

        if (ret) {
            nexus_json_free(json_obj);
            log_error("could not create JSON object\n");
            goto err;
        }

        if (nexus_json_serialize_to_file(json_obj, (char *)filepath)) {
            nexus_json_free(json_obj);
            log_error("nexus_json_serialize_to_file() FAILED\n");
            goto err;
        }

        nexus_json_free(json_obj);
    }

    nexus_free(quote_str);
    nexus_free(pubkey_str);
    nexus_free(privkey_str);

    return 0;
err:
    nexus_free(quote_str);
    nexus_free(pubkey_str);
    nexus_free(privkey_str);

    return -1;
}

static int
read_keypair (const char              * filepath,
              uint8_t                ** quote,
              uint32_t                * quote_len,
              struct ecdh_public_key  * pubkey,
              uint8_t                ** sealed_privkey,
              uint32_t                * sealed_privkey_len)
{
    char * quote_str   = NULL;
    char * pubkey_str  = NULL;
    char * privkey_str = NULL;

    uint8_t  * pubkey_buf = NULL;
    uint32_t   pubkey_len = 0;

    nexus_json_obj_t json_obj = NEXUS_JSON_INVALID_OBJ;

    int ret = -1;

    {
        json_obj = nexus_json_parse_file((char *)filepath);

        if (json_obj == NEXUS_JSON_INVALID_OBJ) {
            log_error("could not parse file: %s\n", filepath);
            return -1;
        }

        if (nexus_json_get_string(json_obj, "quote", &quote_str)) {
            log_error("could not get `quote` from JSON object\n");
            goto out;
        }

        if (nexus_json_get_string(json_obj, "pubkey", &pubkey_str)) {
            log_error("could not get `pubkey` from JSON object\n");
            goto out;
        }

        if (nexus_json_get_string(json_obj, "privkey", &privkey_str)) {
            log_error("could not get `privkey` from JSON object\n");
            goto out;
        }
    }

    ret = 0;

    ret |= nexus_alt64_decode(quote_str, quote, (uint32_t *)quote_len);
    ret |= nexus_alt64_decode(privkey_str, sealed_privkey, sealed_privkey_len);
    ret |= nexus_alt64_decode(pubkey_str, &pubkey_buf, &pubkey_len);

    if (ret == 0) {
        memcpy(pubkey->bytes, pubkey_buf, sizeof(struct ecdh_public_key));
    }
out:
    if (json_obj != NEXUS_JSON_INVALID_OBJ) {
        nexus_json_free(json_obj);
    }

    if (ret) {
        if (*quote) {
            nexus_free(*quote);
            *quote = NULL;
        }

        if (*sealed_privkey) {
            nexus_free(*sealed_privkey);
            *sealed_privkey = NULL;
        }
    }

    if (pubkey_buf) {
        nexus_free(pubkey_buf);
    }

    return ret;
}

int
store_nxs_instance(struct nxs_instance * message, const char * filepath)
{
    return write_keypair(filepath,
                        (uint8_t *)message->quote,
                        message->quote_size,
                        &message->pubkey,
                        message->sealed_privkey,
                        message->privkey_size);
}

struct nxs_instance *
fetch_nxs_instance(const char * filepath)
{
    struct nxs_instance * result = nexus_malloc(sizeof(struct nxs_instance));

    if (read_keypair(filepath,
                     (uint8_t **)&result->quote,
                     &result->quote_size,
                     &result->pubkey,
                     &result->sealed_privkey,
                     &result->privkey_size)) {
        nexus_free(result);
        return NULL;
    }

    return result;
}

void
free_nxs_instance(struct nxs_instance * message)
{
    if (message->quote) {
        nexus_free(message->quote);
    }

    if (message->sealed_privkey) {
        nexus_free(message->sealed_privkey);
    }

    nexus_free(message);
}


int
store_xchg_message(const char * filepath, struct rk_exchange * message)
{
    char * nonce_str = NULL;
    char * ciphertext_str = NULL;
    char * ephe_pk_str = NULL;
    char * vol_uuid_str = NULL;

    nonce_str = nexus_alt64_encode(message->nonce.bytes, sizeof(struct ecdh_nonce));
    ciphertext_str = nexus_alt64_encode(message->ciphertext, message->ciphertext_len);
    ephe_pk_str = nexus_alt64_encode((uint8_t *)&message->ephemeral_pubkey, sizeof(struct ecdh_public_key));
    vol_uuid_str = nexus_alt64_encode((uint8_t *)&message->volume_uuid, sizeof(struct nexus_uuid));

    {
        nexus_json_obj_t json_obj = nexus_json_new_obj(".");

        int ret = 0;

        ret |= nexus_json_add_string(json_obj, "nonce", nonce_str);
        ret |= nexus_json_add_string(json_obj, "ctext", ciphertext_str);
        ret |= nexus_json_add_string(json_obj, "pubkey", ephe_pk_str);
        ret |= nexus_json_add_string(json_obj, "voluuid", vol_uuid_str);

        if (ret) {
            log_error("could not create JSON object\n");
            goto err;
        }

        if (nexus_json_serialize_to_file(json_obj, (char *)filepath)) {
            log_error("nexus_json_serialize_to_file() FAILED\n");
            goto err;
        }

        nexus_json_free(json_obj);
    }

    nexus_free(nonce_str);
    nexus_free(ciphertext_str);
    nexus_free(ephe_pk_str);
    nexus_free(vol_uuid_str);

    return 0;
err:
    nexus_free(nonce_str);
    nexus_free(ciphertext_str);
    nexus_free(ephe_pk_str);
    nexus_free(vol_uuid_str);

    return -1;
}

static inline int
__parse_xchg_json(char *  filepath,
                  char ** nonce_str,
                  char ** ciphertext_str,
                  char ** ephemeral_pk_str,
                  char ** vol_uuid_str)
{

    nexus_json_obj_t json_obj = nexus_json_parse_file(filepath);

    if (json_obj == NEXUS_JSON_INVALID_OBJ) {
        log_error("could not parse file: %s\n", filepath);
        return -1;
    }

    if (nexus_json_get_string(json_obj, "nonce", nonce_str)) {
        log_error("could not get `nonce` from JSON object\n");
        goto out_err;
    }

    if (nexus_json_get_string(json_obj, "ctext", ciphertext_str)) {
        log_error("could not get `ctext` from JSON object\n");
        goto out_err;
    }

    if (nexus_json_get_string(json_obj, "pubkey", ephemeral_pk_str)) {
        log_error("could not get `pubkey` from JSON object\n");
        goto out_err;
    }

    if (nexus_json_get_string(json_obj, "voluuid", vol_uuid_str)) {
        log_error("could not get `vol_uuid` from JSON object\n");
        goto out_err;
    }

    nexus_json_free(json_obj);

    return 0;

out_err:
    nexus_json_free(json_obj);

    return -1;
}

struct rk_exchange *
fetch_xchg_message(const char * filepath)
{
    struct rk_exchange * message = NULL;

    char * ciphertext_str = NULL;

    uint8_t * nonce_buf = NULL;
    char *    nonce_str = NULL;
    uint32_t  nonce_len = 0;

    uint8_t * ephemeral_pk_buf = NULL;
    char *    ephemeral_pk_str = NULL;
    uint32_t  ephemeral_pk_len = 0;

    uint8_t * vol_uuid_buf = NULL;
    char *    vol_uuid_str = NULL;
    uint32_t  vol_uuid_len = 0;

    int ret = -1;



    if (__parse_xchg_json((char *)filepath,
                          &nonce_str,
                          &ciphertext_str,
                          &ephemeral_pk_str,
                          &vol_uuid_str)) {
        log_error("__parse_xchg_json() FAILED\n");
        return NULL;
    }


    ret = 0;

    message = nexus_malloc(sizeof(struct rk_exchange));

    ret |= nexus_alt64_decode(nonce_str, &nonce_buf, &nonce_len);
    ret |= nexus_alt64_decode(ephemeral_pk_str, &ephemeral_pk_buf, &ephemeral_pk_len);
    ret |= nexus_alt64_decode(ciphertext_str,
                              &message->ciphertext,
                              (uint32_t *)&message->ciphertext_len);
    ret |= nexus_alt64_decode(vol_uuid_str, &vol_uuid_buf, &vol_uuid_len);

    if (ret != 0) {
        log_error("Error decoding rootkey exchange message\n");
        goto out;
    }

    if (vol_uuid_len != sizeof(struct nexus_uuid)) {
        log_error("decoded uuid has incorrect size. expected=%zu, got=%d\n",
                  sizeof(struct nexus_uuid),
                  vol_uuid_len);

        ret = -1;
        goto out;
    }

    memcpy(message->ephemeral_pubkey.bytes, ephemeral_pk_buf, sizeof(struct ecdh_public_key));
    memcpy(message->nonce.bytes, nonce_buf, sizeof(struct ecdh_nonce));
    memcpy(&message->volume_uuid, vol_uuid_buf, sizeof(struct nexus_uuid));

    ret = 0;
out:
    if (nonce_buf) {
        nexus_free(nonce_buf);
    }

    if (ephemeral_pk_buf) {
        nexus_free(ephemeral_pk_buf);
    }

    if (vol_uuid_buf) {
        nexus_free(vol_uuid_buf);
    }

    if (ret) {
        free_xchg_message(message);
        return NULL;
    }

    return message;
}

void
free_xchg_message(struct rk_exchange * message)
{
    if (message->ciphertext) {
        nexus_free(message->ciphertext);
    }

    nexus_free(message);
}
