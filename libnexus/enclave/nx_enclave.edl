enclave {

    include "nexus.h"

    trusted {

        public int ecall_init_enclave();

        // supernode stuff
        /**
         * Creates a new nexus volume
         * @param supernode_uuid_in is the uuid of the supernode
         * @param root_uuid_in will be the root uuid
         * @param supernode_buffer_out will be the output buffer of the supernode
         * @param dirnode_buffer_out will be the output buffer of the dirnode
         * @param volume_rootkey_out sealed rootkey
         */
        public int ecall_create_volume(
            [user_check] struct uuid * supernode_uuid_ext,
            [user_check] struct uuid * root_uuid_ext,
            [in, string] const char * publickey_str_in,
            size_t publickey_str_len,
            [user_check] struct supernode * supernode_buffer_ext,
            [user_check] struct dirnode * dirnode_buffer_ext,
            [user_check] struct volumekey * volume_rootkey_ext
        );
                                    
        /**
         * Initiates a user authentication with the enclave. The enclave responds
         * with a nonce challenge.
         * @param publickey_str_in is the user's public key
         * @param nonce_out will be the attached challenge
         */
        public int ecall_authentication_request(
            [in, string] const char * publickey_str_in,
            size_t publickey_str_len,
            [out] nonce_t * nonce_ext
        );

        /**
         * Responds to the enclave challenge from above.
         * @param volume_rootkey_in the sealed volume rootkey
         * @param supernode_in the supernode to authenticate
         * @param signature_in [nonce | supernode_in] user_privatekey
         * @param signature_len
         * @return 0 on success
         */
        public int ecall_authentication_response(
            [in] struct volumekey * volume_key_in,
            [user_check] struct supernode * supernode_ext,
            [user_check] uint8_t * signature_ext,
            size_t signature_len
        );

        // dirnode stuff

        /**
         * Creates a new dirnode 
         * @param uuid_ext the dirnode's uuid
         * @param parent_dirnode_ext the dirnode of the parent directory
         * @param dirnode_out_ext destination pointer for the new dirnode.
         * @return 0 on success
         */
        public int ecall_dirnode_new(
            [user_check] struct uuid * uuid_ext,
            [user_check] struct dirnode * parent_dirnode_ext,
            [user_check] struct dirnode * dirnode_out_ext
        );

        /**
         * Add a new file/dir into the dirnode
         * @param dirnode_ext
         * @param 
         * @param dirnode_out_ext destination pointer for the new dirnode.
         * @return 0 on success
         */
        public int ecall_dirnode_add(
            [user_check] struct dirnode * dirnode_ext,
            [user_check] struct uuid * uuid,
            [in, string] const char * fname_str_in,
            nexus_fs_obj_type_t type
        );

        public int ecall_dirnode_find_by_uuid(
            [user_check] struct dirnode *      sealed_dirnode_ext,
            [user_check] struct uuid *         uuid_ext,
            [user_check] char **               fname_str_out_ext,
            [user_check] nexus_fs_obj_type_t * type_out_ext
        );

        public int ecall_dirnode_find_by_name(
            [user_check] struct dirnode *      sealed_dirnode_ext,
            [user_check] char *                fname_str_ext,
            [user_check] struct uuid *         uuid_out_ext,
            [user_check] nexus_fs_obj_type_t * type_out_ext
        );

        public int ecall_dirnode_remove(
            [user_check] struct dirnode *      sealed_dirnode_ext,
            [user_check] char *                fname_str_ext,
            [user_check] struct uuid *         uuid_out_ext,
            [user_check] nexus_fs_obj_type_t * type_out_ext
        );

        public int ecall_dirnode_serialize(
            [user_check] struct dirnode * dirnode,
            [user_check] struct dirnode ** p_sealed_dirnode_out_ext
        );
    };

    untrusted {
        void ocall_print([in, string] const char * str);

        // performs an allocation in untrusted space
        void * ocall_calloc(size_t size);
    };

};
