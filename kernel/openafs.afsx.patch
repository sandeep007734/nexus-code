diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 4d484c1..3717a3d 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -345,9 +345,7 @@ afs_try_to_freeze(void) {
 static inline void
 afs_try_to_freeze(void) {
 # ifdef CONFIG_PM
-    if (current->flags & PF_FREEZE) {
-	refrigerator(PF_FREEZE);
-    }
+    try_to_freeze();
 # endif
 }
 #endif
diff --git a/src/afs/LINUX/osi_module.c b/src/afs/LINUX/osi_module.c
index 0b34f1a..7cfbd37 100644
--- a/src/afs/LINUX/osi_module.c
+++ b/src/afs/LINUX/osi_module.c
@@ -119,7 +119,7 @@ afs_cleanup(void)
     return;
 }
 
-MODULE_LICENSE("http://www.openafs.org/dl/license10.html");
+MODULE_LICENSE("GPL");
 module_init(afs_init);
 module_exit(afs_cleanup);
 
diff --git a/src/afs/LINUX/osi_pag_module.c b/src/afs/LINUX/osi_pag_module.c
index ac4f800..4033fad 100644
--- a/src/afs/LINUX/osi_pag_module.c
+++ b/src/afs/LINUX/osi_pag_module.c
@@ -110,7 +110,7 @@ afspag_cleanup(void)
     return;
 }
 
-MODULE_LICENSE("http://www.openafs.org/dl/license10.html");
+MODULE_LICENSE("GPL");
 module_init(afspag_init);
 module_exit(afspag_cleanup);
 
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 1b99c94..3862858 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -315,6 +315,13 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
     cred_t *credp = crref();
     struct afs_fakestat_state fakestat;
 
+#ifdef AFS_SECURE
+    char * dirpath = NULL;
+    /* since the offset in the afs and vfs differ, we need to calculate
+     * these variables whenever there's a resulting afs_find */
+    int is_ucafs_file = 0, uc_len, uc_offset;
+#endif
+
     AFS_GLOCK();
     AFS_STATCNT(afs_readdir);
 
@@ -383,6 +390,12 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 #else
     offset = (int) fp->f_pos;
 #endif
+
+#ifdef AFS_SECURE
+    UCAFS_ignore_dentry(fp->f_path.dentry, &dirpath);
+    uc_offset = offset;
+#endif
+
     while (1) {
 	dirpos = BlobScan(tdc, offset);
 	if (!dirpos)
@@ -406,6 +419,11 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	    struct VenusFid afid;
 	    struct vcache *tvc;
 	    int vtype;
+
+#ifdef AFS_SECURE
+	    char * uc_name = de->name;
+	    uc_len = len;
+#endif
 	    afid.Cell = avc->f.fid.Cell;
 	    afid.Fid.Volume = avc->f.fid.Fid.Volume;
 	    afid.Fid.Vnode = ntohl(de->fid.vnode);
@@ -437,19 +455,62 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	     * holding the GLOCK.
 	     */
 	    AFS_GUNLOCK();
+
+#ifdef AFS_SECURE
+	    is_ucafs_file = 0;
+	    if (dirpath) {
+		char * res;
+		int find = 1;
+		ucafs_entry_type file_type;
+
+		if (dirpath == NULL) {
+		    find = 0;
+		}
+
+		if (find) {
+		    if (type == DT_REG) {
+			file_type = UCAFS_TYPE_FILE;
+		    } else if (type == DT_DIR) {
+			file_type = UCAFS_TYPE_DIR;
+		    } else {
+			file_type = UCAFS_TYPE_UNKNOWN;
+		    }
+
+		    if ((uc_name[0] == '.' && uc_name[1] == '\0') ||
+			(uc_name[0] == '.' && uc_name[1] == '.' && uc_name[2] == '\0')) {
+			find = 0;
+		    }
+
+		    if (find && !UCAFS_find(&res, de->name, file_type, dirpath)) {
+		        is_ucafs_file = 1;
+			uc_name = res;
+			uc_len = strlen(uc_name);
+		    }
+		}
+	    }
+#endif
 #if defined(STRUCT_FILE_OPERATIONS_HAS_ITERATE)
 	    /* dir_emit returns a bool - true when it succeeds.
 	     * Inverse the result to fit with how we check "code" */
-	    code = !dir_emit(ctx, de->name, len, ino, type);
+	    code = !dir_emit(ctx, uc_name, uc_len, ino, type);
 #else
-	    code = (*filldir) (dirbuf, de->name, len, offset, ino, type);
+	    code = (*filldir) (dirbuf, uc_name, uc_len, uc_offset, ino, type);
+#endif
+
+#ifdef AFS_SECURE
+	    if (is_ucafs_file) {
+	        osi_linux_free(uc_name);
+	    }
 #endif
+
 	    AFS_GLOCK();
 	}
+
 	DRelease(de, 0);
 	if (code)
 	    break;
 	offset = dirpos + 1 + ((len + 16) >> 5);
+	uc_offset = dirpos + 1 + ((uc_len + 16) >> 5);
     }
     /* If filldir didn't fill in the last one this is still pointing to that
      * last attempt.
@@ -461,6 +522,12 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 #endif
     code = 0;
 
+#ifdef AFS_SECURE
+    if (dirpath) {
+        kfree(dirpath);
+    }
+#endif
+
 unlock_out:
     ReleaseReadLock(&tdc->lock);
     afs_PutDCache(tdc);
@@ -570,6 +637,8 @@ afs_linux_fsync(struct file *fp, int datasync)
     struct inode *ip = FILE_INODE(fp);
     cred_t *credp = crref();
 
+    printk(KERN_ERR "fsync: writing %s\n", fp->f_path.dentry->d_name.name);
+
 #if defined(FOP_FSYNC_TAKES_RANGE)
     mutex_lock(&ip->i_mutex);
 #endif
@@ -954,6 +1023,7 @@ check_bad_parent(struct dentry *dp)
 	credp = crref();
 
 	/* force a lookup, so vcp->mvid is fixed up */
+	printk(KERN_ERR "checking for bad parent: %s\n", (char *)dp->d_name.name);
 	code = afs_lookup(pvc, (char *)dp->d_name.name, &avc, credp);
 	if (code || vcp != avc) {	/* bad, very bad.. */
 	    afs_Trace4(afs_iclSetp, CM_TRACE_TMP_1S3L, ICL_TYPE_STRING,
@@ -1235,6 +1305,7 @@ afs_linux_dentry_revalidate(struct dentry *dp, int flags)
 	    int lookup_good;
 
 	    credp = crref();
+	    printk(KERN_ERR "revalidate_dcache: %s\n", (char *)dp->d_name.name);
 	    code = afs_lookup(pvcp, (char *)dp->d_name.name, &tvc, credp);
 
 	    if (code) {
@@ -1459,6 +1530,10 @@ afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
     struct vcache *vcp;
     int code;
 
+#ifdef AFS_SECURE
+    int is_ucafs_file = 0;
+#endif
+
     AFS_GLOCK();
 
     code = afs_CreateAttr(&vattr);
@@ -1468,6 +1543,17 @@ afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
     vattr->va_mode = mode;
     vattr->va_type = mode & S_IFMT;
 
+#ifdef AFS_SECURE
+    {
+	char * crypto_name = NULL;
+
+	if (!UCAFS_create(&crypto_name, UCAFS_TYPE_FILE, dp)) {
+	    is_ucafs_file = 1;
+	    name = crypto_name;
+	}
+    }
+#endif
+
     code = afs_create(VTOAFS(dip), (char *)name, vattr, NONEXCL, mode,
 		      &vcp, credp);
 
@@ -1486,6 +1572,12 @@ afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
 
     afs_DestroyAttr(vattr);
 
+#ifdef AFS_SECURE
+    if (is_ucafs_file) {
+	osi_linux_free((void *)name);
+    }
+#endif
+
 out:
     AFS_GUNLOCK();
 
@@ -1512,9 +1604,33 @@ afs_linux_lookup(struct inode *dip, struct dentry *dp)
     struct dentry *newdp = NULL;
     int code;
 
+#ifdef AFS_SECURE
+    int is_ucafs_file = 0;
+#endif
+
     AFS_GLOCK();
+
+#ifdef AFS_SECURE
+    {
+	char * dest;
+
+	if (UCAFS_lookup(&dest, dp) == 0) {
+	    is_ucafs_file = 1;
+	    comp = dest;
+	    /*printk(KERN_ERR "afs_lookup: %s -> %s\n", comp,
+		    dp ? dp->d_name.name : NULL);*/
+	}
+    }
+#endif
+
     code = afs_lookup(VTOAFS(dip), (char *)comp, &vcp, credp);
 
+#ifdef AFS_SECURE
+    if (is_ucafs_file) {
+        osi_linux_free((void *)comp);
+    }
+#endif
+
     if (!code) {
 	struct vattr *vattr = NULL;
 	struct vcache *parent_vc = VTOAFS(dip);
@@ -1614,14 +1730,38 @@ afs_linux_link(struct dentry *olddp, struct inode *dip, struct dentry *newdp)
     const char *name = newdp->d_name.name;
     struct inode *oldip = olddp->d_inode;
 
-    /* If afs_link returned the vnode, we could instantiate the
+#ifdef AFS_SECURE
+    int is_ucafs_file = 0;
+#endif
+
+   /* If afs_link returned the vnode, we could instantiate the
      * dentry. Since it's not, we drop this one and do a new lookup.
      */
     d_drop(newdp);
 
     AFS_GLOCK();
+
+#ifdef AFS_SECURE
+    printk(KERN_ERR "hardlink: %s -> %s\n", (char *)olddp->d_name.name,
+	(char *)newdp->d_name.name);
+    {
+        char * crypto_name = NULL;
+
+	if (!UCAFS_hardlink(&crypto_name, newdp, olddp)) {
+	    name = crypto_name;
+	    is_ucafs_file = 1;
+	}
+    }
+#endif
+
     code = afs_link(VTOAFS(oldip), VTOAFS(dip), (char *)name, credp);
 
+#ifdef AFS_SECURE
+    if (is_ucafs_file) {
+        osi_linux_free((void *)name);
+    }
+#endif
+
     AFS_GUNLOCK();
     crfree(credp);
     return afs_convert_code(code);
@@ -1641,6 +1781,9 @@ afs_linux_sillyrename(struct inode *dir, struct dentry *dentry,
     struct dentry *__dp = NULL;
     char *__name = NULL;
     int code;
+    /* ucafs code */
+    char * ucafs_name = NULL, * shadow_name = NULL;
+    int is_ucafs_file = 1;
 
     if (afs_linux_nfsfs_renamed(dentry))
 	return EBUSY;
@@ -1663,7 +1806,19 @@ afs_linux_sillyrename(struct inode *dir, struct dentry *dentry,
     } while (__dp->d_inode != NULL);
 
     AFS_GLOCK();
-    code = afs_rename(VTOAFS(dir), (char *)dentry->d_name.name,
+
+    /* ucafs code */
+    printk(KERN_ERR "sillyrename: %s -> %s\n", dentry->d_name.name,
+           __dp->d_name.name);
+    if (UCAFS_lookup(&ucafs_name, dentry) == 0) {
+	shadow_name = ucafs_name;
+	is_ucafs_file = 1;
+        uc_silly_add(__dp->d_name.name, dentry->d_name.name, shadow_name);
+    } else {
+	shadow_name = dentry->d_name.name;
+    }
+
+    code = afs_rename(VTOAFS(dir), shadow_name,
 		      VTOAFS(dir), (char *)__dp->d_name.name,
 		      credp);
     if (!code) {
@@ -1678,6 +1833,12 @@ afs_linux_sillyrename(struct inode *dir, struct dentry *dentry,
     } else {
 	osi_FreeSmallSpace(__name);
     }
+
+    /* ucafs code */
+    if (is_ucafs_file) {
+	kfree(shadow_name);
+    }
+
     AFS_GUNLOCK();
 
     if (!code) {
@@ -1698,6 +1859,8 @@ afs_linux_unlink(struct inode *dip, struct dentry *dp)
     const char *name = dp->d_name.name;
     struct vcache *tvc = VTOAFS(dp->d_inode);
 
+    printk(KERN_ERR "removing: %s\n", name);
+
     if (VREFCOUNT(tvc) > 1 && tvc->opens > 0
 				&& !(tvc->f.states & CUnlinked)) {
 
@@ -1723,6 +1886,10 @@ afs_linux_symlink(struct inode *dip, struct dentry *dp, const char *target)
     struct vattr *vattr = NULL;
     const char *name = dp->d_name.name;
 
+#ifdef AFS_SECURE
+    int is_ucafs_file = 0;
+#endif
+
     /* If afs_symlink returned the vnode, we could instantiate the
      * dentry. Since it's not, we drop this one and do a new lookup.
      */
@@ -1734,10 +1901,27 @@ afs_linux_symlink(struct inode *dip, struct dentry *dp, const char *target)
 	goto out;
     }
 
+#ifdef AFS_SECURE
+    printk(KERN_ERR"symlinking: %s, target=%s\n", name, target);
+    {
+        char * crypto_name = NULL;
+
+	if (!UCAFS_create(&crypto_name, UCAFS_TYPE_LINK, dp)) {
+	    name = crypto_name;
+	    is_ucafs_file = 1;
+	}
+    }
+#endif
     code = afs_symlink(VTOAFS(dip), (char *)name, vattr, (char *)target, NULL,
 			credp);
     afs_DestroyAttr(vattr);
 
+#ifdef AFS_SECURE
+    if (is_ucafs_file) {
+        osi_linux_free((void *)name);
+    }
+#endif
+
 out:
     AFS_GUNLOCK();
     crfree(credp);
@@ -1757,6 +1941,10 @@ afs_linux_mkdir(struct inode *dip, struct dentry *dp, int mode)
     struct vattr *vattr = NULL;
     const char *name = dp->d_name.name;
 
+#ifdef AFS_SECURE
+    int is_ucafs_file = 0;
+#endif
+
     AFS_GLOCK();
     code = afs_CreateAttr(&vattr);
     if (code) {
@@ -1766,8 +1954,25 @@ afs_linux_mkdir(struct inode *dip, struct dentry *dp, int mode)
     vattr->va_mask = ATTR_MODE;
     vattr->va_mode = mode;
 
+#ifdef AFS_SECURE
+    {
+        char * crypto_name = NULL;
+
+	if (!UCAFS_create(&crypto_name, UCAFS_TYPE_DIR, dp)) {
+	    is_ucafs_file = 1;
+	    name = crypto_name;
+	}
+    }
+#endif
+
     code = afs_mkdir(VTOAFS(dip), (char *)name, vattr, &tvcp, credp);
 
+#ifdef AFS_SECURE
+    if (is_ucafs_file) {
+	osi_linux_free((void *)name);
+    }
+#endif
+
     if (tvcp) {
 	struct inode *ip = AFSTOV(tvcp);
 
@@ -1798,6 +2003,16 @@ afs_linux_rmdir(struct inode *dip, struct dentry *dp)
 
     /* locking kernel conflicts with glock? */
 
+#ifdef AFS_SECURE
+    {
+	char * dest;
+        if (!UCAFS_remove(&dest, dp)) {
+            /*printk(KERN_ERR "afs_unlink: %s -> %s\n", name, dest);*/
+            name = dest;
+        }
+    }
+#endif
+
     AFS_GLOCK();
     code = afs_rmdir(VTOAFS(dip), (char *)name, credp);
     AFS_GUNLOCK();
@@ -1829,7 +2044,11 @@ afs_linux_rename(struct inode *oldip, struct dentry *olddp,
     const char *newname = newdp->d_name.name;
     struct dentry *rehash = NULL;
 
-    /* Prevent any new references during rename operation. */
+#ifdef AFS_SECURE
+    int is_ucafs_file = 0;
+#endif
+
+   /* Prevent any new references during rename operation. */
 
     if (!d_unhashed(newdp)) {
 	d_drop(newdp);
@@ -1838,10 +2057,29 @@ afs_linux_rename(struct inode *oldip, struct dentry *olddp,
 
     afs_maybe_shrink_dcache(olddp);
 
+#ifdef AFS_SECURE
+    {
+        char * dest;
+        if (!UCAFS_rename(&dest, olddp, newdp)) {
+	    /*printk(KERN_ERR "rename: oldname=%s, newname=%s\n", oldname,
+		newname);*/
+	    is_ucafs_file = 1;
+	    newname = dest;
+	    oldname = dest;
+	}
+    }
+#endif
+
     AFS_GLOCK();
     code = afs_rename(VTOAFS(oldip), (char *)oldname, VTOAFS(newip), (char *)newname, credp);
     AFS_GUNLOCK();
 
+#ifdef AFS_SECURE
+    if (is_ucafs_file) {
+	//osi_linux_free((void *)newname);
+    }
+#endif
+
     if (!code)
 	olddp->d_time = 0;      /* force to revalidate */
 
@@ -1868,6 +2106,8 @@ afs_linux_ireadlink(struct inode *ip, char *target, int maxlen, uio_seg_t seg)
     memset(&tuio, 0, sizeof(tuio));
     memset(&iov, 0, sizeof(iov));
 
+    printk(KERN_ERR "readlink: %s\n", target);
+
     setup_uio(&tuio, &iov, target, (afs_offs_t) 0, maxlen, UIO_READ, seg);
     code = afs_readlink(VTOAFS(ip), &tuio, credp);
     crfree(credp);
diff --git a/src/afs/VNOPS/afs_vnop_remove.c b/src/afs/VNOPS/afs_vnop_remove.c
index 3e62781..6088729 100644
--- a/src/afs/VNOPS/afs_vnop_remove.c
+++ b/src/afs/VNOPS/afs_vnop_remove.c
@@ -183,6 +183,11 @@ afs_remove(OSI_VC_DECL(adp), char *aname, afs_ucred_t *acred)
     struct vcache *tvc;
     afs_size_t offset, len;
     struct afs_fakestat_state fakestate;
+    /* ucafs_code */
+    char * ucafs_path = NULL, * ucafs_name1 = NULL, * ucafs_name2,
+	 * old_aname = NULL;
+    int ret, is_ucafs_file = 0;
+
     OSI_VC_CONVERT(adp);
 
     AFS_STATCNT(afs_remove);
@@ -255,6 +260,19 @@ afs_remove(OSI_VC_DECL(adp), char *aname, afs_ucred_t *acred)
 	goto tagain;
     }
 
+    /* ucafs code */
+    is_ucafs_file = (ucafs_vnode_path(adp, &ucafs_path) == 0);
+    if (is_ucafs_file) {
+	ret = ucafs_plain2code(ucafs_path, aname, UCAFS_TYPE_FILE, &ucafs_name1);
+	if (ret == 0) {
+	    old_aname = aname;
+	    aname = ucafs_name1;
+	} else {
+	    is_ucafs_file = 0;
+	    kfree(ucafs_path);
+	}
+    }
+
     unlinkFid.Fid.Vnode = 0;
     if (!tvc) {
 	tvc = osi_dnlc_lookup(adp, aname, WRITE_LOCK);
@@ -350,12 +368,16 @@ afs_remove(OSI_VC_DECL(adp), char *aname, afs_ucred_t *acred)
 	ReleaseWriteLock(&adp->lock);
 	if (tdc)
 	    ReleaseSharedLock(&tdc->lock);
+	/* ucafs code */
+	uc_silly_add(unlname, old_aname, ucafs_name1);
+
 	code = afsrename(adp, aname, adp, unlname, acred, treq);
 	Tnam1 = unlname;
 	if (!code) {
 	    struct VenusFid *oldmvid = NULL;
 	    if (tvc->mvid) 
 		oldmvid = tvc->mvid;
+	    printk(KERN_ERR "redoing: %s->%s", unlname, aname);
 	    tvc->mvid = (struct VenusFid *)unlname;
 	    if (oldmvid)
 		osi_FreeSmallSpace(oldmvid);
@@ -378,7 +400,20 @@ afs_remove(OSI_VC_DECL(adp), char *aname, afs_ucred_t *acred)
 	    afs_PutDCache(tdc);
 	afs_PutVCache(tvc);
     } else {
+        printk(KERN_ERR "vnop_remove: %s\n", aname);
+	if (is_ucafs_file) {
+	    // TODO implement delete by shadow name
+	    if (ucafs_remove2(ucafs_path, old_aname, UCAFS_TYPE_FILE,
+			&ucafs_name2) == 0) {
+		// strcmp(aname, ucafs_name2) == 0;
+		kfree(ucafs_name2);
+	    }
+	}
 	code = afsremove(adp, tdc, tvc, aname, acred, treq);
+
+	if (is_ucafs_file) {
+	    kfree(ucafs_name1);
+	}
     }
     done:
     afs_PutFakeStat(&fakestate);
@@ -407,6 +442,8 @@ afs_remunlink(struct vcache *avc, int doit)
     struct VenusFid dirFid;
     struct dcache *tdc;
     afs_int32 code = 0;
+    /* ucafs code */
+    char * ucafs_name = NULL;
 
     if (NBObtainWriteLock(&avc->lock, 423))
 	return 0;
@@ -431,6 +468,14 @@ afs_remunlink(struct vcache *avc, int doit)
 	    cred = avc->uncred;
 	    avc->uncred = NULL;
 
+	    /* ucafs code */
+	    ucafs_name = uc_silly_get(unlname);
+	    if (ucafs_name) {
+		printk(KERN_ERR "unlname = %s\n", unlname);
+		// TODO, free existing unlname
+		unlname = ucafs_name;
+	    }
+
 #if defined(AFS_DARWIN_ENV) && !defined(AFS_DARWIN80_ENV)
 	    VREF(AFSTOV(avc));
 #else
diff --git a/src/afs/VNOPS/afs_vnop_rename.c b/src/afs/VNOPS/afs_vnop_rename.c
index 468555a..d121021 100644
--- a/src/afs/VNOPS/afs_vnop_rename.c
+++ b/src/afs/VNOPS/afs_vnop_rename.c
@@ -154,6 +154,7 @@ afsrename(struct vcache *aodp, char *aname1, struct vcache *andp,
     if (code == 0)
 	code = afs_dir_Lookup(tdc1, aname1, &fileFid.Fid);
     if (code) {
+        printk(KERN_ERR "%s was not found.\n", aname1);
 	if (tdc1) {
 	    ReleaseWriteLock(&tdc1->lock);
 	    afs_PutDCache(tdc1);
diff --git a/src/afs/afs.h b/src/afs/afs.h
index f03609c..176f33a 100644
--- a/src/afs/afs.h
+++ b/src/afs/afs.h
@@ -600,6 +600,7 @@ struct SimpleLocks {
 #define CNSHARE		0x00000100	/* support O_NSHARE semantics */
 #define CLied		0x00000200
 #define CTruth		0x00000400
+#define CDecrypted	0x00000800	/* has this file been decrypted since last fetch */
 
 #if defined(AFS_DARWIN80_ENV)
 #define CDeadVnode        0x00000800
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index e8b8f9d..7e15a39 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -159,6 +159,11 @@ afs_Daemon(void)
     afs_osi_ctxtp = vfs_context_create(NULL);
     afs_osi_ctxtp_initialized = 1;
 #endif
+
+#ifdef AFS_SECURE
+    LINUX_AFSX_connect();
+#endif
+
     now = osi_Time();
     lastCBSlotBump = now;
 
@@ -176,6 +181,10 @@ afs_Daemon(void)
     while (1) {
 	afs_CheckCallbacks(20);	/* unstat anything which will expire soon */
 
+#ifdef AFS_SECURE
+	LINUX_AFSX_ping();
+#endif
+
 	/* things to do every 20 seconds or less - required by protocol spec */
 	if (afs_nfsexporter)
 	    afs_FlushActiveVcaches(0);	/* flush NFS writes */
diff --git a/src/afs/afs_fetchstore.c b/src/afs/afs_fetchstore.c
index f494677..2ae469a 100644
--- a/src/afs/afs_fetchstore.c
+++ b/src/afs/afs_fetchstore.c
@@ -1146,6 +1146,13 @@ afs_CacheFetchProc(struct afs_conn *tc, struct rx_connection *rxconn,
     afs_size_t bytesToXfer = 0, bytesXferred = 0;
 #endif
 
+    /* ucafs code */
+    code = UCAFS_get(tc, rxconn, fP, base, adc, avc, size, tsmall);
+    if (code != AFSX_STATUS_NOOP) {
+	return code;
+    }
+    code = 0;
+
     AFS_STATCNT(CacheFetchProc);
 
     XSTATS_START_TIME(AFS_STATS_FS_RPCIDX_FETCHDATA);
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index 9e9f65b..4569746 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -1384,4 +1384,8 @@ extern u_short afs_uuid_hash(afsUUID * uuid);
 #include "osi_prototypes.h"
 #endif
 
+#ifdef AFS_SECURE
+#include "ucafs_prototypes.h"
+#endif
+
 #endif /* _AFS_PROTOTYPES_H_ */
diff --git a/src/afs/afs_segments.c b/src/afs/afs_segments.c
index 2dd89cf..186b4da 100644
--- a/src/afs/afs_segments.c
+++ b/src/afs/afs_segments.c
@@ -173,6 +173,13 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
     afs_size_t maxStoredLength;	/* highest offset we've written to server. */
     int safety, marineronce = 0;
 
+    /* ucafs code */
+    code = UCAFS_store(avc, areq);
+    if (code != AFSX_STATUS_NOOP) {
+	return code;
+    }
+    code = 0;
+
     AFS_STATCNT(afs_StoreAllSegments);
 
     hash = DVHash(&avc->f.fid);
diff --git a/src/afs/lock.h b/src/afs/lock.h
index 74cd300..4d04a0e 100644
--- a/src/afs/lock.h
+++ b/src/afs/lock.h
@@ -171,7 +171,7 @@ typedef struct afs_lock afs_rwlock_t;
 
 extern int afs_trclock;
 
-#define AFS_LOCK_TRACE_ENABLE 0
+#define AFS_LOCK_TRACE_ENABLE 1
 #if AFS_LOCK_TRACE_ENABLE
 #define AFS_LOCK_TRACE(op, lock, type) \
 	if (afs_trclock) Afs_Lock_Trace(op, lock, type, __FILE__, __LINE__);
diff --git a/src/libafs/Makefile.common.in b/src/libafs/Makefile.common.in
index 46b9c9d..d8aa994 100644
--- a/src/libafs/Makefile.common.in
+++ b/src/libafs/Makefile.common.in
@@ -104,6 +104,13 @@ AFSAOBJS = \
 	afs_osi_vm.o \
 	afs_segments.o \
 	afs_server.o \
+	ucafs_main.o \
+	ucafs_dnlc.o \
+	ucafs_dirops.o \
+	ucafs_fetch.o \
+	ucafs_get.o \
+	ucafs_store.o \
+	afsx.cs.o \
 	afs_stat.o \
 	afs_syscall.o \
 	afs_user.o \
@@ -283,6 +290,20 @@ afs_segments.o: $(TOP_SRC_AFS)/afs_segments.c
 	$(CRULE_OPT)
 afs_server.o: $(TOP_SRC_AFS)/afs_server.c
 	$(CRULE_OPT)
+ucafs_main.o: $(TOP_SRC_AFS)/ucafs_main.c
+	$(crule_opt)
+ucafs_dnlc.o: $(TOP_SRC_AFS)/ucafs_dnlc.c
+	$(CRULE_OPT)
+ucafs_dirops.o: $(TOP_SRC_AFS)/ucafs_dirops.c
+	$(CRULE_OPT)
+ucafs_fetch.o: $(TOP_SRC_AFS)/ucafs_fetch.c
+	$(CRULE_OPT)
+ucafs_get.o: $(TOP_SRC_AFS)/ucafs_get.c
+	$(CRULE_OPT)
+ucafs_store.o: $(TOP_SRC_AFS)/ucafs_store.c
+	$(CRULE_OPT)
+afsx.cs.o: $(TOP_SRC_AFS)/afsx.cs.c
+	$(CRULE_OPT)
 afs_user.o: $(TOP_SRC_AFS)/afs_user.c
 	$(CRULE_OPT)
 afs_util.o: $(TOP_SRC_AFS)/afs_util.c
