diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 1b99c94..103ec15 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -406,6 +406,8 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	    struct VenusFid afid;
 	    struct vcache *tvc;
 	    int vtype;
+	    char * dentry_name;
+
 	    afid.Cell = avc->f.fid.Cell;
 	    afid.Fid.Volume = avc->f.fid.Fid.Volume;
 	    afid.Fid.Vnode = ntohl(de->fid.vnode);
@@ -437,12 +439,29 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	     * holding the GLOCK.
 	     */
 	    AFS_GUNLOCK();
+
+	    dentry_name = de->name;
+#ifdef AFS_SECURE
+	    {
+	        char buf[500];
+	        char * path, * res;
+		path = dentry_path_raw(fp->f_dentry, buf, sizeof(buf));
+
+		if (!LINUX_AFSX_ignore_path_bool(path)) {
+		     if (!LINUX_AFSX_realname(&res, de->name, path)) {
+		         printk(KERN_DEBUG "afs_filldir: %s -> %s\n", de->name, res);
+			 dentry_name = res;
+		     }
+		}
+	    }
+#endif
+
 #if defined(STRUCT_FILE_OPERATIONS_HAS_ITERATE)
 	    /* dir_emit returns a bool - true when it succeeds.
 	     * Inverse the result to fit with how we check "code" */
-	    code = !dir_emit(ctx, de->name, len, ino, type);
+	    code = !dir_emit(ctx, dentry_name, len, ino, type);
 #else
-	    code = (*filldir) (dirbuf, de->name, len, offset, ino, type);
+	    code = (*filldir) (dirbuf, dentry_name, len, offset, ino, type);
 #endif
 	    AFS_GLOCK();
 	}
@@ -1468,6 +1487,35 @@ afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
     vattr->va_mode = mode;
     vattr->va_type = mode & S_IFMT;
 
+#ifdef AFS_SECURE
+    {
+        char fname[500];
+        char * path, * crypto_name = NULL, * crypto_name_cpy = NULL;
+        int ret = 0, len = 0;
+
+        path = dentry_path_raw(dp, fname, sizeof(fname));
+        // if we are not touching a .fbox file
+        if (!LINUX_AFSX_ignore_path_bool(path)) {
+            if (!LINUX_AFSX_newfile(&crypto_name, path)) {
+		printk(KERN_ERR "ret is here (%d)\n", ret);
+
+		len = strlen(crypto_name);
+		/* we make a copy because the buffer returned is from rx. I'm not
+		 * sure if they use it later. Just playing it safe here. FOR NOW */
+		crypto_name_cpy = kmalloc(len + 1, GFP_KERNEL);
+		if (crypto_name_cpy) {
+		    crypto_name_cpy[len] = '\0';
+		    memcpy(crypto_name_cpy, crypto_name, len);
+		    name = crypto_name_cpy;
+		    printk(KERN_ERR "dir: %s\n", path);
+		} else {
+		    printk(KERN_ERR "could not allocate memory for crypto name\n");
+		}
+            }
+        }
+    }
+#endif
+
     code = afs_create(VTOAFS(dip), (char *)name, vattr, NONEXCL, mode,
 		      &vcp, credp);
 
@@ -1487,6 +1535,7 @@ afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
     afs_DestroyAttr(vattr);
 
 out:
+    printk(KERN_ERR "file created: %s\n", name);
     AFS_GUNLOCK();
 
     crfree(credp);
@@ -1513,6 +1562,23 @@ afs_linux_lookup(struct inode *dip, struct dentry *dp)
     int code;
 
     AFS_GLOCK();
+
+#ifdef AFS_SECURE
+    {
+        char fname[500];
+	char * path, * dest;
+	
+	path = dentry_path_raw(dp, fname, sizeof(fname));
+	if (!LINUX_AFSX_ignore_path_bool(path)) {
+	    if (!LINUX_AFSX_lookup(&dest, path)) {
+		comp = dest;
+	        printk(KERN_ERR "afs_lookup: %s -> %s\n", comp,
+		    newdp ? newdp->d_name.name : NULL);
+	    }
+	}
+    }
+#endif
+
     code = afs_lookup(VTOAFS(dip), (char *)comp, &vcp, credp);
 
     if (!code) {
@@ -1698,6 +1764,21 @@ afs_linux_unlink(struct inode *dip, struct dentry *dp)
     const char *name = dp->d_name.name;
     struct vcache *tvc = VTOAFS(dp->d_inode);
 
+#ifdef AFS_SECURE
+    {
+        char fname[500];
+	char * path, * dest;
+	
+	path = dentry_path_raw(dp, fname, sizeof(fname));
+	if (!LINUX_AFSX_ignore_path_bool(path)) {
+	    if (!LINUX_AFSX_delfile(&dest, path)) {
+	        printk(KERN_ERR "afs_unlink: %s -> %s\n", name, dest);
+		name = dest;
+	    }
+	} 
+    }
+#endif
+
     if (VREFCOUNT(tvc) > 1 && tvc->opens > 0
 				&& !(tvc->f.states & CUnlinked)) {
 
@@ -1838,6 +1919,8 @@ afs_linux_rename(struct inode *oldip, struct dentry *olddp,
 
     afs_maybe_shrink_dcache(olddp);
 
+    printk(KERN_ERR "afs_rename: %s -> %s\n", oldname, newname);
+
     AFS_GLOCK();
     code = afs_rename(VTOAFS(oldip), (char *)oldname, VTOAFS(newip), (char *)newname, credp);
     AFS_GUNLOCK();
diff --git a/src/afs/VNOPS/afs_vnop_open.c b/src/afs/VNOPS/afs_vnop_open.c
index 0c90bf16..f1b1fe8 100644
--- a/src/afs/VNOPS/afs_vnop_open.c
+++ b/src/afs/VNOPS/afs_vnop_open.c
@@ -164,6 +164,18 @@ afs_open(struct vcache **avcp, afs_int32 aflags, afs_ucred_t *acred)
     }
 #endif
     ReleaseReadLock(&tvc->lock);
+
+#ifdef AFS_SECURE
+    #include "afsx_defs.h"
+    if ((writing == 0) && (vType(tvc) != VDIR)) {
+	code = LINUX_AFSX_fetch(tvc, treq);
+	printk(KERN_ERR "afsx_fetch returned %d\n", code);
+	if (code != AFSX_STATUS_NOOP) {
+	    goto done;
+	}
+    }
+#endif
+
     if ((afs_preCache != 0) && (writing == 0) && (vType(tvc) != VDIR) && 
 	(!afs_BBusy())) {
 	struct dcache *tdc;
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index e8b8f9d..7e15a39 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -159,6 +159,11 @@ afs_Daemon(void)
     afs_osi_ctxtp = vfs_context_create(NULL);
     afs_osi_ctxtp_initialized = 1;
 #endif
+
+#ifdef AFS_SECURE
+    LINUX_AFSX_connect();
+#endif
+
     now = osi_Time();
     lastCBSlotBump = now;
 
@@ -176,6 +181,10 @@ afs_Daemon(void)
     while (1) {
 	afs_CheckCallbacks(20);	/* unstat anything which will expire soon */
 
+#ifdef AFS_SECURE
+	LINUX_AFSX_ping();
+#endif
+
 	/* things to do every 20 seconds or less - required by protocol spec */
 	if (afs_nfsexporter)
 	    afs_FlushActiveVcaches(0);	/* flush NFS writes */
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index 9e9f65b..fe8d680 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -1384,4 +1384,8 @@ extern u_short afs_uuid_hash(afsUUID * uuid);
 #include "osi_prototypes.h"
 #endif
 
+#ifdef AFS_SECURE
+#include "afs_secure.h"
+#endif
+
 #endif /* _AFS_PROTOTYPES_H_ */
diff --git a/src/afs/afs_segments.c b/src/afs/afs_segments.c
index 2dd89cf..982f39c 100644
--- a/src/afs/afs_segments.c
+++ b/src/afs/afs_segments.c
@@ -173,6 +173,16 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
     afs_size_t maxStoredLength;	/* highest offset we've written to server. */
     int safety, marineronce = 0;
 
+#ifdef AFS_SECURE
+#include "afsx_defs.h"
+    code = LINUX_AFSX_store(avc, areq);
+    if (code == AFSX_STATUS_SUCCESS || code == AFSX_STATUS_ERROR) {
+	printk(KERN_ERR "upload_file returned %d\n", code);
+	return code;
+    }
+    code = 0;
+#endif 
+
     AFS_STATCNT(afs_StoreAllSegments);
 
     hash = DVHash(&avc->f.fid);
diff --git a/src/libafs/Makefile.common.in b/src/libafs/Makefile.common.in
index 46b9c9d..9d7c4e6 100644
--- a/src/libafs/Makefile.common.in
+++ b/src/libafs/Makefile.common.in
@@ -104,6 +104,8 @@ AFSAOBJS = \
 	afs_osi_vm.o \
 	afs_segments.o \
 	afs_server.o \
+	afs_secure.o \
+	afsx.cs.o \
 	afs_stat.o \
 	afs_syscall.o \
 	afs_user.o \
@@ -283,6 +285,10 @@ afs_segments.o: $(TOP_SRC_AFS)/afs_segments.c
 	$(CRULE_OPT)
 afs_server.o: $(TOP_SRC_AFS)/afs_server.c
 	$(CRULE_OPT)
+afs_secure.o: $(TOP_SRC_AFS)/afs_secure.c
+	$(CRULE_OPT)
+afsx.cs.o: $(TOP_SRC_AFS)/afsx.cs.c
+	$(CRULE_OPT)
 afs_user.o: $(TOP_SRC_AFS)/afs_user.c
 	$(CRULE_OPT)
 afs_util.o: $(TOP_SRC_AFS)/afs_util.c
