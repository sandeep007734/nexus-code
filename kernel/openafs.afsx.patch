diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 1b99c94..a8f1ed3 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -314,6 +314,9 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
     afs_size_t origOffset, tlen;
     cred_t *credp = crref();
     struct afs_fakestat_state fakestat;
+    /* ucafs code */
+    char * ucafs_path = NULL, * uc_name = NULL, * real_name = NULL;
+    int is_ucafs_file = 0, uc_len, uc_offset;
 
     AFS_GLOCK();
     AFS_STATCNT(afs_readdir);
@@ -383,6 +386,11 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 #else
     offset = (int) fp->f_pos;
 #endif
+
+    /* ucafs code */
+    // if parent_path != NULL, we are in an sgx directory
+    ucafs_vnode_path(avc, &ucafs_path);
+    uc_offset = 0;
     while (1) {
 	dirpos = BlobScan(tdc, offset);
 	if (!dirpos)
@@ -437,12 +445,40 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	     * holding the GLOCK.
 	     */
 	    AFS_GUNLOCK();
+	    /* ucafs code */
+	    is_ucafs_file = 0;
+	    uc_name = de->name;
+	    uc_len = len;
+
+	    if (ucafs_path) {
+		ucafs_entry_type uc_type = UC_ANY;
+
+		if (type == DT_REG) {
+		    uc_type = UC_FILE;
+		} else if (type == DT_DIR) {
+		    uc_type = UC_DIR;
+		}
+
+		/* let's make sure we never send the . and .. */
+		if ((uc_name[0] == '.' && uc_name[1] == '\0') ||
+			(uc_name[0] == '.' && uc_name[1] == '.' &&
+			    uc_name[2] == '\0')) {
+		    goto skip;
+		}
+
+		if (ucafs_find(ucafs_path, uc_name, uc_type, &real_name) == 0) {
+		    is_ucafs_file = 1;
+		    uc_name = real_name;
+		    uc_len = strlen(uc_name);
+		}
+	    }
+skip:
 #if defined(STRUCT_FILE_OPERATIONS_HAS_ITERATE)
 	    /* dir_emit returns a bool - true when it succeeds.
 	     * Inverse the result to fit with how we check "code" */
-	    code = !dir_emit(ctx, de->name, len, ino, type);
+	    code = !dir_emit(ctx, uc_name, uc_len, ino, type);
 #else
-	    code = (*filldir) (dirbuf, de->name, len, offset, ino, type);
+	    code = (*filldir) (dirbuf, uc_name, uc_len, offset, ino, type);
 #endif
 	    AFS_GLOCK();
 	}
@@ -450,14 +486,19 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	if (code)
 	    break;
 	offset = dirpos + 1 + ((len + 16) >> 5);
+	/* ucafs code */
+	uc_offset = dirpos + 1 + ((uc_len + 16) >> 5);
+	if (is_ucafs_file) {
+	    kfree(uc_name);
+	}
     }
     /* If filldir didn't fill in the last one this is still pointing to that
      * last attempt.
      */
 #if defined(STRUCT_FILE_OPERATIONS_HAS_ITERATE)
-    ctx->pos = (loff_t) offset;
+    ctx->pos = (loff_t) uc_offset;
 #else
-    fp->f_pos = (loff_t) offset;
+    fp->f_pos = (loff_t) uc_offset;
 #endif
     code = 0;
 
@@ -475,6 +516,10 @@ out:
     afs_DestroyReq(treq);
 out1:
     AFS_GUNLOCK();
+    /* ucafs code */
+    if (ucafs_path) {
+	kfree(ucafs_path);
+    }
     return code;
 }
 
@@ -1698,6 +1743,9 @@ afs_linux_unlink(struct inode *dip, struct dentry *dp)
     const char *name = dp->d_name.name;
     struct vcache *tvc = VTOAFS(dp->d_inode);
 
+    printk(KERN_ERR "name=%s ref=%d, opens=%d, unlinked=%d\n", name,
+	VREFCOUNT(tvc), tvc->opens, (tvc->f.states & CUnlinked));
+
     if (VREFCOUNT(tvc) > 1 && tvc->opens > 0
 				&& !(tvc->f.states & CUnlinked)) {
 
diff --git a/src/afs/VNOPS/afs_vnop_create.c b/src/afs/VNOPS/afs_vnop_create.c
index f33da96..a536d98 100644
--- a/src/afs/VNOPS/afs_vnop_create.c
+++ b/src/afs/VNOPS/afs_vnop_create.c
@@ -58,6 +58,11 @@ afs_create(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
     struct afs_fakestat_state fakestate;
     struct rx_connection *rxconn;
     XSTATS_DECLS;
+
+    /* ucafs code */
+    char * shadow_name = NULL;
+    int is_ucafs_file = 0, ret;
+
     OSI_VC_CONVERT(adp);
 
     AFS_STATCNT(afs_create);
@@ -112,6 +117,15 @@ afs_create(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
     code = afs_EvalFakeStat(&adp, &fakestate, treq);
     if (code)
 	goto done;
+
+    /* ucafs code */
+    // TODO the file creation might fail
+    ret = ucafs_create(adp, aname, UC_FILE, &shadow_name);
+    if (ret == 0) {
+	is_ucafs_file = 1;
+	aname = shadow_name;
+    }
+
   tagain:
     code = afs_VerifyVCache(adp, treq);
     if (code)
@@ -503,6 +517,10 @@ afs_create(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
     afs_DestroyReq(treq);
 
   done2:
+    /* ucafs code */
+    if (is_ucafs_file) {
+	kfree(shadow_name);
+    }
     osi_FreeSmallSpace(OutFidStatus);
     osi_FreeSmallSpace(OutDirStatus);
     return code;
diff --git a/src/afs/VNOPS/afs_vnop_dirops.c b/src/afs/VNOPS/afs_vnop_dirops.c
index 33455cb..3b4f20e 100644
--- a/src/afs/VNOPS/afs_vnop_dirops.c
+++ b/src/afs/VNOPS/afs_vnop_dirops.c
@@ -53,6 +53,11 @@ afs_mkdir(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
     afs_int32 now;
     struct afs_fakestat_state fakestate;
     XSTATS_DECLS;
+
+    /* ucafs code */
+    int is_ucafs_file = 0, ret;
+    char * ucafs_name = NULL;
+
     OSI_VC_CONVERT(adp);
 
     AFS_STATCNT(afs_mkdir);
@@ -106,6 +111,12 @@ afs_mkdir(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
     tdc = afs_GetDCache(adp, (afs_size_t) 0, treq, &offset, &len, 1);
     ObtainWriteLock(&adp->lock, 153);
 
+    ret = ucafs_create(adp, aname, UC_DIR, &ucafs_name);
+    if (ret == 0) {
+	is_ucafs_file = 1;
+	aname = ucafs_name;
+    }
+
     if (!AFS_IS_DISCON_RW) {
     	do {
 	    tc = afs_Conn(&adp->f.fid, treq, SHARED_LOCK, &rxconn);
@@ -247,6 +258,11 @@ afs_mkdir(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
     code = afs_CheckCode(code, treq, 26);
     afs_DestroyReq(treq);
   done2:
+    /* ucafs code */
+    if (is_ucafs_file) {
+	kfree(ucafs_name);
+    }
+
     osi_FreeSmallSpace(OutFidStatus);
     osi_FreeSmallSpace(OutDirStatus);
     return code;
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index e8b8f9d..521359e 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -161,6 +161,8 @@ afs_Daemon(void)
 #endif
     now = osi_Time();
     lastCBSlotBump = now;
+    /* ucafs code */
+    ucafs_connect();
 
     /* when a lot of clients are booted simultaneously, they develop
      * annoying synchronous VL server bashing behaviors.  So we stagger them.
@@ -175,6 +177,8 @@ afs_Daemon(void)
     /* start off with afs_initState >= 101 (basic init done) */
     while (1) {
 	afs_CheckCallbacks(20);	/* unstat anything which will expire soon */
+	/* ucafs code */
+	ucafs_ping();
 
 	/* things to do every 20 seconds or less - required by protocol spec */
 	if (afs_nfsexporter)
diff --git a/src/afs/afs_osidnlc.c b/src/afs/afs_osidnlc.c
index 9df2b0d..d33accd 100644
--- a/src/afs/afs_osidnlc.c
+++ b/src/afs/afs_osidnlc.c
@@ -305,7 +305,7 @@ osi_dnlc_lookup(struct vcache *adp, char *aname, int locktype)
 	}
 #endif
     }
-
+    printk("Found tvc: name=%s\n", aname);
     return tvc;
 }
 
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index 9e9f65b..b3ccf39 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -1384,4 +1384,7 @@ extern u_short afs_uuid_hash(afsUUID * uuid);
 #include "osi_prototypes.h"
 #endif
 
+/* ucafs code */
+#include "ucafs_prototypes.h"
+
 #endif /* _AFS_PROTOTYPES_H_ */
diff --git a/src/afs/afs_vcache.c b/src/afs/afs_vcache.c
index ca5a956..b32787d 100644
--- a/src/afs/afs_vcache.c
+++ b/src/afs/afs_vcache.c
@@ -1928,6 +1928,9 @@ afs_LookupVCache(struct VenusFid *afid, struct vrequest *areq,
     struct server *serverp = 0;
     afs_int32 origCBs;
     afs_int32 retry;
+    /* ucafs code */
+    char * uc_shadow_name = NULL;
+    int is_ucafs_file = 0;
 
     AFS_STATCNT(afs_GetVCache);
     if (cached)
@@ -1975,10 +1978,21 @@ afs_LookupVCache(struct VenusFid *afid, struct vrequest *areq,
 	/* printf("Network is down in afs_LookupVcache\n"); */
         code = ENETDOWN;
     } else
+	/* ucafs code: if we are here, we can get the realname to lookup */
+	if (ucafs_lookup(adp, aname, UC_ANY, &uc_shadow_name) == 0) {
+	    is_ucafs_file = 1;
+	    aname = uc_shadow_name;
+	}
+
         code =
 	    afs_RemoteLookup(&adp->f.fid, areq, aname, &nfid, &OutStatus,
 	                     &CallBack, &serverp, &tsync);
 
+	/* ucafs code */
+	if (is_ucafs_file) {
+	    kfree(uc_shadow_name);
+	}
+
 #if	defined(AFS_SGI_ENV) && !defined(AFS_SGI53_ENV)
   loop2:
 #endif
diff --git a/src/libafs/Makefile.common.in b/src/libafs/Makefile.common.in
index 46b9c9d..16bc674 100644
--- a/src/libafs/Makefile.common.in
+++ b/src/libafs/Makefile.common.in
@@ -230,6 +230,16 @@ AFSPAGOBJS = \
 	xdr.o		\
 	afs_uuid.o $(AFS_OS_PAGOBJS)
 
+# ucafs objects
+UCAFSOBJS = \
+			ucafs_main.o \
+			ucafs_dirops.o
+
+ucafs_main.o: $(TOP_SRC_AFS)/ucafs_main.c
+	$(CRULE_NOOPT)
+
+ucafs_dirops.o: $(TOP_SRC_AFS)/ucafs_dirops.c
+	$(CRULE_NOOPT)
 
 # Compilation rules
 # These files are to be optimized
