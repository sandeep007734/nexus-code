diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 1b99c94..2128623 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -123,17 +123,30 @@ afs_linux_aio_read(struct kiocb *iocb, const struct iovec *buf,
     unsigned long bufsize = iter->nr_segs;
 # endif
 
-
     AFS_GLOCK();
     afs_Trace4(afs_iclSetp, CM_TRACE_AIOREADOP, ICL_TYPE_POINTER, vcp,
 	       ICL_TYPE_OFFSET, ICL_HANDLE_OFFSET(pos), ICL_TYPE_INT32,
                (afs_int32)bufsize, ICL_TYPE_INT32, 99999);
     code = afs_linux_VerifyVCache(vcp, NULL);
-
+#ifdef AFS_SECURE
+#include "afsx_hdr.h"
+    {
+        struct vrequest * treq;
+	cred_t * credp = crref();
+	afs_CreateReq(&treq, credp);
+	code = UCAFS_fetch(vcp, treq);
+	if (code == AFSX_STATUS_NOOP) {
+	    code = 0;
+	}
+	afs_DestroyReq(treq);
+	crfree(credp);
+    }
+#endif
     if (code == 0) {
 	/* Linux's FlushPages implementation doesn't ever use credp,
 	 * so we optimise by not using it */
 	osi_FlushPages(vcp, NULL);	/* ensure stale pages are gone */
+
 	AFS_GUNLOCK();
 # if defined(STRUCT_FILE_OPERATIONS_HAS_READ_ITER)
 	code = generic_file_read_iter(iocb, iter);
@@ -315,6 +328,10 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
     cred_t *credp = crref();
     struct afs_fakestat_state fakestat;
 
+#ifdef AFS_SECURE
+    char * dirpath = NULL;
+#endif
+
     AFS_GLOCK();
     AFS_STATCNT(afs_readdir);
 
@@ -374,6 +391,10 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
     avc->readdir_pid = MyPidxx2Pid(MyPidxx);
     ConvertWToSLock(&avc->lock);
 
+#ifdef AFS_SECURE
+    UCAFS_ignore_dentry(fp->f_path.dentry, &dirpath);
+#endif
+
     /* Fill in until we get an error or we're done. This implementation
      * takes an offset in units of blobs, rather than bytes.
      */
@@ -406,6 +427,8 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	    struct VenusFid afid;
 	    struct vcache *tvc;
 	    int vtype;
+	    char * dentry_name;
+
 	    afid.Cell = avc->f.fid.Cell;
 	    afid.Fid.Volume = avc->f.fid.Fid.Volume;
 	    afid.Fid.Vnode = ntohl(de->fid.vnode);
@@ -437,20 +460,60 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	     * holding the GLOCK.
 	     */
 	    AFS_GUNLOCK();
+
+	    dentry_name = de->name;
+#ifdef AFS_SECURE
+	    {
+		char * res = de->name;
+		int find = 1;
+		ucafs_entry_type file_type;
+
+		if (dirpath == NULL) {
+		    find = 0;
+		}
+
+		if (find) {
+		    if (type == DT_REG) {
+			file_type = UCAFS_TYPE_FILE;
+		    } else if (type == DT_DIR) {
+			file_type = UCAFS_TYPE_DIR;
+		    } else {
+			file_type = UCAFS_TYPE_UNKNOWN;
+		    }
+
+		    if ((de->name[0] == '.' && de->name[1] == '\0') ||
+			(de->name[0] == '.' && de->name[1] == '.' && de->name[2] == '\0')) {
+			find = 0;
+		    }
+
+		    if (!UCAFS_find(&res, de->name, file_type, dirpath)) {
+			dentry_name = res;
+		    }
+		}
+	    }
+#endif
+
 #if defined(STRUCT_FILE_OPERATIONS_HAS_ITERATE)
 	    /* dir_emit returns a bool - true when it succeeds.
 	     * Inverse the result to fit with how we check "code" */
-	    code = !dir_emit(ctx, de->name, len, ino, type);
+	    code = !dir_emit(ctx, dentry_name, len, ino, type);
 #else
-	    code = (*filldir) (dirbuf, de->name, len, offset, ino, type);
+	    code = (*filldir) (dirbuf, dentry_name, len, offset, ino, type);
 #endif
 	    AFS_GLOCK();
 	}
+
 	DRelease(de, 0);
 	if (code)
 	    break;
 	offset = dirpos + 1 + ((len + 16) >> 5);
     }
+
+#ifdef AFS_SECURE
+    if (dirpath) {
+	kfree(dirpath);
+    }
+#endif
     /* If filldir didn't fill in the last one this is still pointing to that
      * last attempt.
      */
@@ -1468,6 +1531,16 @@ afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
     vattr->va_mode = mode;
     vattr->va_type = mode & S_IFMT;
 
+#ifdef AFS_SECURE
+    {
+	char * crypto_name = NULL;
+
+	if (!UCAFS_create(&crypto_name, UCAFS_TYPE_FILE, dp)) {
+	    name = crypto_name;
+	}
+    }
+#endif
+
     code = afs_create(VTOAFS(dip), (char *)name, vattr, NONEXCL, mode,
 		      &vcp, credp);
 
@@ -1513,6 +1586,19 @@ afs_linux_lookup(struct inode *dip, struct dentry *dp)
     int code;
 
     AFS_GLOCK();
+
+#ifdef AFS_SECURE
+    {
+	char * dest;
+	
+	if (!UCAFS_lookup(&dest, dp)) {
+	    comp = dest;
+	    /*printk(KERN_ERR "afs_lookup: %s -> %s\n", comp,
+		    dp ? dp->d_name.name : NULL);*/
+	}
+    }
+#endif
+
     code = afs_lookup(VTOAFS(dip), (char *)comp, &vcp, credp);
 
     if (!code) {
@@ -1704,6 +1790,16 @@ afs_linux_unlink(struct inode *dip, struct dentry *dp)
 	code = afs_linux_sillyrename(dip, dp, credp);
     } else {
 	AFS_GLOCK();
+
+#ifdef AFS_SECURE
+	{
+	    char * dest;
+	    if (!UCAFS_remove(&dest, dp)) {
+		printk(KERN_ERR "afs_unlink: %s -> %s\n", name, dest);
+		name = dest;
+	    }
+	}
+#endif
 	code = afs_remove(VTOAFS(dip), (char *)name, credp);
 	AFS_GUNLOCK();
 	if (!code)
@@ -1734,6 +1830,16 @@ afs_linux_symlink(struct inode *dip, struct dentry *dp, const char *target)
 	goto out;
     }
 
+#ifdef AFS_SECURE
+    printk(KERN_ERR"symlinking: %s, target=%s\n", name, target);
+    {
+        char * crypto_name = NULL;
+
+	if (!UCAFS_create(&crypto_name, UCAFS_TYPE_LINK, dp)) {
+	    name = crypto_name;
+	}
+    }
+#endif
     code = afs_symlink(VTOAFS(dip), (char *)name, vattr, (char *)target, NULL,
 			credp);
     afs_DestroyAttr(vattr);
@@ -1766,6 +1872,16 @@ afs_linux_mkdir(struct inode *dip, struct dentry *dp, int mode)
     vattr->va_mask = ATTR_MODE;
     vattr->va_mode = mode;
 
+#ifdef AFS_SECURE
+    {
+        char * crypto_name = NULL;
+
+	if (!UCAFS_create(&crypto_name, UCAFS_TYPE_DIR, dp)) {
+	    name = crypto_name;
+	}
+    }
+#endif
+
     code = afs_mkdir(VTOAFS(dip), (char *)name, vattr, &tvcp, credp);
 
     if (tvcp) {
@@ -1798,6 +1914,16 @@ afs_linux_rmdir(struct inode *dip, struct dentry *dp)
 
     /* locking kernel conflicts with glock? */
 
+#ifdef AFS_SECURE
+    {
+	char * dest;
+        if (!UCAFS_remove(&dest, dp)) {
+            printk(KERN_ERR "afs_unlink: %s -> %s\n", name, dest);
+            name = dest;
+        }
+    }
+#endif
+
     AFS_GLOCK();
     code = afs_rmdir(VTOAFS(dip), (char *)name, credp);
     AFS_GUNLOCK();
@@ -1838,6 +1964,18 @@ afs_linux_rename(struct inode *oldip, struct dentry *olddp,
 
     afs_maybe_shrink_dcache(olddp);
 
+#ifdef AFS_SECURE
+    {
+        char * dest;
+        if (!UCAFS_rename(&dest, olddp, newdp)) {
+	    printk(KERN_ERR "rename: oldname=%s, newname=%s\n", oldname,
+		newname);
+	    newname = dest;
+	    oldname = dest;
+	}  
+    }
+#endif
+
     AFS_GLOCK();
     code = afs_rename(VTOAFS(oldip), (char *)oldname, VTOAFS(newip), (char *)newname, credp);
     AFS_GUNLOCK();
@@ -1868,6 +2006,8 @@ afs_linux_ireadlink(struct inode *ip, char *target, int maxlen, uio_seg_t seg)
     memset(&tuio, 0, sizeof(tuio));
     memset(&iov, 0, sizeof(iov));
 
+    printk(KERN_ERR, "readlink: %s\n", target);
+
     setup_uio(&tuio, &iov, target, (afs_offs_t) 0, maxlen, UIO_READ, seg);
     code = afs_readlink(VTOAFS(ip), &tuio, credp);
     crfree(credp);
diff --git a/src/afs/afs.h b/src/afs/afs.h
index f03609c..176f33a 100644
--- a/src/afs/afs.h
+++ b/src/afs/afs.h
@@ -600,6 +600,7 @@ struct SimpleLocks {
 #define CNSHARE		0x00000100	/* support O_NSHARE semantics */
 #define CLied		0x00000200
 #define CTruth		0x00000400
+#define CDecrypted	0x00000800	/* has this file been decrypted since last fetch */
 
 #if defined(AFS_DARWIN80_ENV)
 #define CDeadVnode        0x00000800
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index e8b8f9d..7e15a39 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -159,6 +159,11 @@ afs_Daemon(void)
     afs_osi_ctxtp = vfs_context_create(NULL);
     afs_osi_ctxtp_initialized = 1;
 #endif
+
+#ifdef AFS_SECURE
+    LINUX_AFSX_connect();
+#endif
+
     now = osi_Time();
     lastCBSlotBump = now;
 
@@ -176,6 +181,10 @@ afs_Daemon(void)
     while (1) {
 	afs_CheckCallbacks(20);	/* unstat anything which will expire soon */
 
+#ifdef AFS_SECURE
+	LINUX_AFSX_ping();
+#endif
+
 	/* things to do every 20 seconds or less - required by protocol spec */
 	if (afs_nfsexporter)
 	    afs_FlushActiveVcaches(0);	/* flush NFS writes */
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index 9e9f65b..fe8d680 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -1384,4 +1384,8 @@ extern u_short afs_uuid_hash(afsUUID * uuid);
 #include "osi_prototypes.h"
 #endif
 
+#ifdef AFS_SECURE
+#include "afs_secure.h"
+#endif
+
 #endif /* _AFS_PROTOTYPES_H_ */
diff --git a/src/afs/afs_segments.c b/src/afs/afs_segments.c
index 2dd89cf..f80359b 100644
--- a/src/afs/afs_segments.c
+++ b/src/afs/afs_segments.c
@@ -173,6 +173,15 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
     afs_size_t maxStoredLength;	/* highest offset we've written to server. */
     int safety, marineronce = 0;
 
+#ifdef AFS_SECURE
+#include "afsx_hdr.h"
+    code = UCAFS_store(avc, areq);
+    if (code != AFSX_STATUS_NOOP) {
+	return code;
+    }
+    code = 0;
+#endif 
+
     AFS_STATCNT(afs_StoreAllSegments);
 
     hash = DVHash(&avc->f.fid);
diff --git a/src/libafs/Makefile.common.in b/src/libafs/Makefile.common.in
index 46b9c9d..210320a 100644
--- a/src/libafs/Makefile.common.in
+++ b/src/libafs/Makefile.common.in
@@ -104,6 +104,10 @@ AFSAOBJS = \
 	afs_osi_vm.o \
 	afs_segments.o \
 	afs_server.o \
+	ucafs_main.o \
+	ucafs_fetch.o \
+	ucafs_store.o \
+	afsx.cs.o \
 	afs_stat.o \
 	afs_syscall.o \
 	afs_user.o \
@@ -283,6 +287,14 @@ afs_segments.o: $(TOP_SRC_AFS)/afs_segments.c
 	$(CRULE_OPT)
 afs_server.o: $(TOP_SRC_AFS)/afs_server.c
 	$(CRULE_OPT)
+ucafs_main.o: $(TOP_SRC_AFS)/ucafs_main.c
+	$(CRULE_OPT)
+ucafs_fetch.o: $(TOP_SRC_AFS)/ucafs_fetch.c
+	$(CRULE_OPT)
+ucafs_store.o: $(TOP_SRC_AFS)/ucafs_store.c
+	$(CRULE_OPT)
+afsx.cs.o: $(TOP_SRC_AFS)/afsx.cs.c
+	$(CRULE_OPT)
 afs_user.o: $(TOP_SRC_AFS)/afs_user.c
 	$(CRULE_OPT)
 afs_util.o: $(TOP_SRC_AFS)/afs_util.c
